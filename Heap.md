# Heap

- **힙(heap)**: 우선순위 큐를 구현하기 위해 만들어진 자료구조



## 우선순위 큐

- **우선순위 큐(priority queue)**: 요소들이 우선순위를 가져, 우선순위가 높은 데이터부터 먼저 나가는 큐
- 우선순위 큐의 사용
  - 시뮬레이션 시스템
  - 네트워크 트래픽 제어
  - 운영 체제에서 작업 스케줄링



### 우선순위 큐의 종류

우선순위 큐는 요소를 삭제하는 기준에 따라 두 가지로 나눌 수 있다.

1. 최소 우선순위 큐: 가장 우선순위가 낮은 요소부터 삭제
2. **최대 우선순위 큐**: 가장 우선순위가 높은 요소부터 삭제



여기서는 `최대 우선순위 큐`만을 다룬다.



### 우선순위 큐의 연산

- `is_empty(우선순위큐)`: 우선순위 큐가 비어있는지 검사한다.
- `insert(우선순위큐, 요소)`: 우선순위 큐에 요소를 추가한다.
- `delete(우선순위큐)`: 우선순위 큐에서 가장 우선순위가 높은 요소를 꺼내어 반환한다.
- `find(우선순위큐)`: 우선순위 큐에서 가장 우선순위가 높은 요소를 (삭제 없이) 반환한다.



### 우선순위 큐의 구현

우선순위 큐는 세 가지 자료구조를 사용해 구현할 수 있다.

1. 배열: 요소의 값이 우선순위를 표현
2. 연결 리스트
3. 힙(hep)



이중에서도 `힙`으로 구현하는 것이 가장 효율적이다.

| 방법                  | 삽입      | 삭제      | 설명                                                         |
| --------------------- | --------- | --------- | ------------------------------------------------------------ |
| 순서 없는 배열        | `O(1)`    | `O(n)`    | 삽입: 우선순위를 고려하지 않고 삽입하므로 상수 시간에 가능하다.<br />삭제: 요소가 우선순위에 따라 정렬되어있지 않으므로 탐색에 `O(n)`의 시간복잡도가 필요하다. |
| 순서 없는 연결 리스트 | `O(1)`    | `O(n)`    | 삽입: 우선순위를 고려하지 않고 삽입하므로 상수 시간에 가능하다.<br />삭제: 요소가 우선순위에 따라 정렬되어있지 않으므로 탐색에 `O(n)`의 시간복잡도가 필요하다. |
| 정렬된 배열           | `O(n)`    | `O(1)`    | 삽입: 우선순위를 고려하여 삽입해야하므로, 탐색에 `O(n)`의 시간복잡도가 필요하다.<br />삭제: 요소가 우선순위에 따라 정렬되어 있으므로 상수 시간에 삭제가 가능하다. |
| 힙                    | `O(logn)` | `O(logn)` | 이후 설명                                                    |



## 힙의 특징

- **완전 이진 트리(complete binary tree)**에 속한다.
- 이진 트리이므로 **이진 힙(binary heap)**이라고도 한다.
- 일종의 반(half) 정렬 상태로, `O(logn)`의 시간 복잡도로 최대값 또는 최소값에 접근할 수 있도록 고안되었다.
- **배열**에 기반한 자료구조이다.



## 힙의 종류

<img src="https://user-images.githubusercontent.com/57662010/168427249-0949eb56-e549-4b04-8fab-fb7e5e215e7e.jpg" alt="binary heap" width="67%" />

힙은 부모와 자식의 키값에 따라 두 종류로 나눌 수 있다.

1. **최대 히프(max heap)**: 부모 노드의 키값이 자식 노드의 키값보다 크거나 같은 완전 이진 트리이다.
   - 이때 가장 우선순위가 높은 노드는 가장 키값이 큰 노드로, 루트 노드에 있다.

```
부모 노드의 키값 >= 자식 노드의 키값
```

2. **최소 히프(min heap)**: 부모 노드의 키값이 자식 노드의 키값보다 작거나 같은 완전 이진 트리이다.
   - 이때 가장 우선순위가 높은 노드는 가장 키값이 작은 노드로, 루트 노드에 있다.

```python
부모 노드의 키값 <= 자식 노드의 키값
```



## 힙의 구현

힙은 `배열`을 이용하여 구현할 수 있다.

- 완전 이진 트리에서 각 노드에 번호를 붙인다고 할 때, 이 번호를 배열의 인덱스로 생각할 수 있다.
- 부모 노드와 자식 노드의 인덱스를 찾기 쉽다. 단, 루트 노드의 번호가 `1`부터 시작하도록 구현해야한다.

```
왼쪽 자식의 인덱스 = (부모 인덱스) * 2
오른쪽 자식의 인덱스 = (부모 인덱스) * 2 + 1
부모의 인덱스 = (자식 인덱스) / 2
```



### insert

힙에 요소 `i`를 삽입하는 과정을 다음과 같다.

1. 요소를 트리에서 가장 하위 레벨의 최대한 왼쪽으로 삽입한다. 배열에서는 가장 뒤에 요소를 추가한다.
2. 히프의 성질을 만족할 때까지 부모 노드와 삽입한 노드를 교환한다. 이 과정에서 루트 노드에 도착하면 교환을 멈춘다.
   - 최대 히프의 경우: 삽입한 요소가 부모보다 크다면 둘을 교환한다.
   - 최소 히프의 경우: 삽입한 요소가 부모보다 작다면 둘을 교환한다.



### delete

힙에서 요소를 삭제하는 과정은 다음과 같다.

1. 가장 우선순위가 높은 노드인 루트 노드를 삭제한다.
   - 최대 히프의 경우: 가장 우선순위가 높은 노드, 곧 가장 키값이 큰 노드(최대값)는 루트 노드이다.
   - 최소 히프의 경우: 가장 우선순위가 높은 노드, 곧 가장 키값이 작은 노드(최소값)는 루트 노드이다.

2. 트리에서 가장 하위 레벨의 가장 오른쪽에 있는 노드를 골라 루트 노드에 삽입한다. 배열에서는 가장 뒤에 있는 요소이다.
3. 히프의 성질을 만족할 때까지 삽입한 노드와 자식 노드를 교환한다. 이 과정에서 가장 하위 레벨에 도착하면 교환을 멈춘다.
   - 최대 히프의 경우: 삽입한 요소가 자식보다 작다면 둘을 교환한다.
   - 최소 히프의 경우: 삽입한 요소가 자식보다 크다면 둘을 교환한다.



## 힙의 시간 복잡도

| 연산        | 시간 복잡도 | 설명                                                         |
| ----------- | ----------- | ------------------------------------------------------------ |
| `insert(i)` | `O(logn)`   | 최악의 경우 가장 마지막에 삽입한 요소가 루트 노드까지 올라가야 하므로 트리의 높이에 해당하는 수(`logn`)만큼 루프를 돌아야 한다. |
| `delete()`  | `O(logn)`   | 최악의 경우 루트에 삽입한 요소가 최하위 레벨까지 내려가야 하므로 트리의 높이에 해당하는 수(`logn`)만큼 루프를 돌아야 한다. |
| `find()`    | `O(1)`      | 가장 우선순위가 높은 노드는 루트에 있는 노드이기 때문에 상수 시간에 접근할 수 있다. |



## 파이썬과 힙

[파이썬 heapq.md](https://github.com/leegwae/python-dojang/blob/main/heapq.md)

파이썬의 `heapq`는 `최소 힙`의 연산을 지원한다.



| 연산                           | 시간 복잡도 | 설명                                                         |
| ------------------------------ | ----------- | ------------------------------------------------------------ |
| `heapq.heapify(리스트)`        | `O(n)`      | `리스트`의 원소들을 최소 힙의 성질에 적합하도록 재배열한다.  |
| `heapq.heappush(리스트, 요소)` | `O(logn)`   | `리스트`에 `요소`를 삽입한다.                                |
| `heapq.heapop(리스트)`         | `O(logn)`   | `리스트`에서 가장 우선순위가 높은 요소(최소값)을 삭제하고 반환한다. |

