# big-O and Complexity

## 알고리즘의 성능을 분석하기

알고리즘의 성능을 분석하는 데에는 다음과 같이 두 가지 방법이 있다.

- 알고리즘의 수행 시간을 측정하기
- 알고리즘의 복잡도를 분석하기



알고리즘의 수행 시간을 측정하려면, 알고리즘을 실제로 구현하고 수행 시간을 측정해야 한다. 이 방법의 경우 하드웨어나 구현에 사용한 프로그래밍 언어에 따라 수행 시간이 달라질 수 있다.



한편, 알고리즘의 복잡도를 분석하여 성능을 측정하는 경우에는 위 방법과 달리 알고리즘을 구현하거나 수행할 필요가 없다. 알고리즘의 복잡도 분석은 다음과 같이 두 가지로 나뉜다.

- 알고리즘의 시간 복잡도를 분석하기
- 알고리즘의 공간 복잡도를 분석하기



## 빅오 표기법과 시간 복잡도

**시간 복잡도(time complexity)**는 알고리즘의 수행 시간을 표현하는 데 사용되며, 수행되는 연산의 횟수를 입력의 크기에 대한 함수로 나타낸 것이다. 알고리즘의 시간 복잡도는 빅오 표기법을 사용하여 나타낸다.



### 빅오 표기법

알고리즘의 수행 시간은 상한($O$, upper bound), 하한($\mathit\Omega$, lower bound), 평균($\mathit\Theta$)으로 나누어볼 수 있다. 이중 상한에 주목하여 빅오 표기법을 사용한다. **빅오 표기법(big-O notation)**은 $n$에 대한 차수식에서 계수를 무시하고 최고차항에 대해서만 표기하는 것이다. 



어떤 알고리즘을 입력의 크기 $n$에 대해 $3n^2+n+1$만큼 시간이 걸린다고 하자. 이 알고리즘을 빅오 표기법으로 나타내면 $O(n^2)$이다.



#### 빅오 표기법의 종류

| 종류           | 설명                                                         | 알고리즘 예시                                |
| -------------- | ------------------------------------------------------------ | -------------------------------------------- |
| $O(1)$         | 상수 시간을 갖는다(입력값의 크기에 영향을 받지 않는다).      | 해시 테이블의 조회 및 삽입                   |
| $O(log\ n)$    | 입력값의 크기에 거의 영향을 받지 않는다.                     | 이진 검색                                    |
| $O(n)$         | 선형 시간(linear-time) 알고리즘: 실행 시간이 입력값의 크기에 비례한다. | 정렬되지 않은 리스트에서 최댓값, 최솟값 찾기 |
| $O(n\ log\ n)$ |                                                              | 효율 좋은 정렬 알고리즘(병합 정렬)           |
| $O(n^2)$       |                                                              | 비효율적인 정렬 알고리즘(버블 정렬)          |
| $O(2^n)$       |                                                              | 피보나치 수를 재귀로 계산하는 알고리즘       |
| $O(n!)$        | 가장 느린 알고리즘                                           | 외판원 문제를 브루트 포스로 풀이한 경우      |



### 예: factorial 함수의 시간 복잡도

다음은 `n` factorial을 계산하는 함수이다.

```c
int factorial(int n) {
    if (n == 1) return 1;   
    
    int result;
    result = 1;

    for (int i = 1; i <= n; i++)
        result *= i;

    return result;
}
```

이 함수는 입력값 `n`번만큼 루프를 돌아 값을 계산하므로, $O(n)$의 시간 복잡도를 가진다.



### 상한과 최악의 차이

>  빅오 표기법은 주어진 경우(최선, 최악, 평균)에서 수행 시간의 상한을 나타낸다.

알고리즘은 문제의 크기에 따라 연산의 횟수가 달라질 수 있다.



(TODO: 퀵 정렬 예시)



## 공간 복잡도

**공간 복잡도(space complexity)**는 알고리즘 수행에 필요한 자원의 크기를 나타낸다.



어떤 함수가 입력이 종료될 때까지 입력값을 받아 동적으로 배열에 할당해 집어넣는다고 하자. 그렇다면 이 함수의 공간 복잡도는 $O(n)$이 된다.



## 분할 상환 분석

- 분할 상환 분석(Amortized Analysis): 최악의 경우를 여러 번에 걸쳐 골고루 나눠주는 형태로 알고리즘의 시간 복잡도 계산하기

TODO



## 병렬화

- 알고리즘의 병렬화로 실행속도 높이기

TODO

