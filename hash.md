# Hash

-   **해시 함수**는 임의의 크기의 입력값을 고정 크기의 값으로 매핑하는데 사용되는 함수이다.
-   해시 테이블에서 인덱싱을 위하여 해시 함수를 사용하는 것을 **해싱(Hashing)**이라고 한다.



## 로드 팩터

-   **로드 팩터(Load Factor)**는 해시 테이블에 저장된 데이터의 개수 `n`을 해시 테이블의 크기 `k`로 나눈 것이다.

```
load_factor = n / k
```

-   로드 팩터가 클수록 테이블의 성능은 감소한다.
-   자바 10의 경우 로드 팩터가 0.75를 넘어서면 해시 테이블의 공간을 재할당한다.



## 해시 충돌

-   아무리 좋은 해시 함수를 사용하여도 인덱스가 충돌할 수 있다.
-   **해시 충돌(Collosion)**을 피하는 것이 해시 테이블의 관건이다.
-   비둘기집 원리를 예로 들어보자.
    -   `n` 마리의 비둘기를 `m` 개의 상자에 넣을 때, `n > m`을 만족한다면 적어도 하나의 상자에는 두 마리 이상의 비둘기가 들어가게 된다.



## 충돌의 해결

### 개별 체이닝

-   **개별 체이닝**은 충돌이 발생하면 값을 연결 리스트로 연결하는 방식이다.
-   전통적인 해시 테이블의 방식이다.
    -   (1) 키의 해시 값을 계산한다.
    -   (2) 해시 값을 이용하여 배열의 인덱스를 구한다.
    -   (3) 인덱스가 충돌한다면 연결 리스트로 연결한다.
-   대부분의 탐색은 `O(1)`이나 최악의 경우(모든 데이터에서 해시 충돌이 발생하는 경우) `O(n)`이다.

### 오픈 어드레싱

-   **오픈 어드레싱(Open Addressing)** 방식은 충돌이 발생하면 빈 공간을 탐사(Probing)하는 방식이다.
-   개별 체이닝과 다음과 같은 차이점을 가진다.
    -   해시 테이블의 전체 크기 이상으로 저장할 수 없다.
    -   모든 원소가 자신의 해시값과 일치하는 주소에 저장된다는 보장이 없다.
-   오픈 어드레싱의 종류
    -   **선형 탐사(Linear Probing)**: 충돌이 발생하면 해당 위치부터 순차적으로 탐사를 진행한다. 비어 있으면 탐사를 멈추고 삽입한다.
        -   문제점: **클러스터링(Clustering)**이 발생한다.
            -   해시 테이블이 골고루 사용되지 않고 특정 부분에서만 연속하여 클러스터를 이룬다.
            -   클러스터들이 점점 커지면 인근과 합쳐진다.
            -   탐사 시간을 늘려 해싱 효율을 떨어뜨린다.
    -   제곱 탐사
-   **리해싱(Rehasing)**: 로드 팩터가 기준을 넘어서면 그로스 팩터(Growth Factor)의 비율에 따라 더 큰 크기의 메모리에 기존 해시 테이블을 복사한다.
-   Python의 해시 테이블은 로드 팩터가 증가함에 따라 개별 체이닝보다 오픈 어드레싱의 성능이 더 뛰어나므로, 오픈 어드레싱으로 구현되어 있다.



## 파이썬과 해시

파이썬의 딕셔너리는 해시 연산을 지원한다.